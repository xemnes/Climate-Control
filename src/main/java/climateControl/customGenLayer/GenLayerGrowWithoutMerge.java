
package climateControl.customGenLayer;

import climateControl.genLayerPack.GenLayerPack;
import net.minecraft.world.gen.layer.GenLayer;
import net.minecraft.world.gen.layer.IntCache;

/**
 *
 * @author Zeno410
 */
public class GenLayerGrowWithoutMerge extends GenLayerPack {

    public GenLayerGrowWithoutMerge(long par1, GenLayer par3GenLayer,
            int maxLandAdvance, int minSeaAdvance, int changeChances){
        super(par1);
        this.parent = par3GenLayer;
        this.changeChances = changeChances;
        this.maxLandAdvance = maxLandAdvance;
        this.minSeaAdvance = minSeaAdvance;
    }

    public final int changeChances;
    public final int maxLandAdvance;
    public final int minSeaAdvance;
    /**
     * Returns a list of integer values generated by this layer. These may be interpreted as temperatures, rainfall
     * amounts, or biomeList[] indices based on the particular GenLayer subclass.
     */
    public int[] getInts(int par1, int par2, int par3, int par4)
    {
        int i1 = par1 - 2;
        int j1 = par2 - 2;
        int k1 = par3 + 4;
        int l1 = par4 + 4;
        int[] parent = this.parent.getInts(i1, j1, k1, l1);
        int[] aint1 = IntCache.getIntCache(par3 * par4);

        for (int i2 = 0; i2 < par4; i2++)
        {
            for (int j2 = 0; j2 < par3; j2++)
            {
                int up = parent[j2 + 1 + (i2 + 2) * k1];
                int left = parent[j2 + 2 + (i2 + 1) * k1];
                int right = parent[j2 + 2 + (i2 + 3) * k1];
                int down = parent[j2 + 3 + (i2 + 2) * k1];
                int k3 = parent[j2 + 2 + (i2 + 2) * k1];
                this.initChunkSeed((long)(j2 + par1), (long)(i2 + par2));
                if (isOceanic(k3) && (!isOceanic(up) || !isOceanic(left) || !isOceanic(right) || !isOceanic(down))) {
                    boolean acceptable = true;
                    int i4 = k3;
                    // if there's a strip of ocean we have to check growth
                    if ((isOceanic(up)&&isOceanic(down))||(isOceanic(left)&&isOceanic(right))) {


                        int upleft = parent[j2 + 1 + (i2 + 1) * k1];
                        int upright  = parent[j2 + 1 + (i2 + 3) * k1];
                        int downleft = parent[j2 + 3 + (i2 + 1) * k1];
                        int downright = parent[j2 + 3 + (i2 + 3) * k1];
                        if ((isOceanic(up)&&isOceanic(down))) {
                            // block is up-down
                            if ((!isOceanic(left))||(!isOceanic(upleft))||(!isOceanic(downleft))) {

                                if ((!isOceanic(right))||(!isOceanic(upright))||(!isOceanic(downright))) {
                                    // stuff on both sides; STOP
                                    acceptable = false;
                                }
                            }
                        } else {
                            // block is left-right
                            if (!isOceanic(up)||!isOceanic(upleft)||!isOceanic(upright)) {
                                if (!isOceanic(down)||!isOceanic(downleft)||!isOceanic(downright)) {
                                    // stuff on both sides; STOP
                                    acceptable = false;
                                }
                            }

                        }
                    } else {
                        boolean mixedScene = false;
                        // at least one has to be oceanic, we already know there's a land
                        if (isOceanic(up) || isOceanic(left) || isOceanic(right) || isOceanic(down)) {
                            mixedScene = true;
                        }
                        if (mixedScene) {
                            // look for diagonal issues
                            int upleft = parent[j2 + 1 + (i2 + 1) * k1];
                            int upright = parent[j2 + 1 + (i2 + 3) * k1];
                            int downleft = parent[j2 + 3 + (i2 + 1) * k1];
                            int downright = parent[j2 + 3 + (i2 + 3) * k1];
                            if (isOceanic(upleft) && isOceanic(downright)) {
                                if (!isOceanic(up) || !isOceanic(right) || !isOceanic(upright)) {
                                    if (!isOceanic(down) || !isOceanic(left) || !isOceanic(downleft)) {
                                        acceptable = false;
                                    }
                                }

                            }
                            if (isOceanic(upright) && isOceanic(downleft)) {
                                if (!isOceanic(up) || !isOceanic(left) || !isOceanic(upleft)) {
                                    if (!isOceanic(down) || !isOceanic(right) || !isOceanic(downright)) {
                                        acceptable = false;
                                    }
                                }

                            }
                        }

                    }
                    if (acceptable) {
                        int hits = 0;
                        long savedSeed = savedChunkSeed();

                        if (!isOceanic(up)) {
                            this.initChunkSeed((long) (j2 + par1), (long)(i2 + par2));
                            if (this.nextInt(changeChances) < maxLandAdvance) {
                                i4 = up;
                                hits++;
                            }
                        }

                        if (!isOceanic(left)) {
                            this.initChunkSeed((long) (j2 + par1), (long)(i2 + par2));
                            if (this.nextInt(changeChances) < maxLandAdvance) {
                                if (hits == 0) {
                                    i4 = left;
                                } else {
                                    if (i4 != left) {
                                        restoreChunkSeed(savedSeed);
                                        if (nextInt(hits) == 0) {
                                            i4 = left;
                                        }
                                        savedSeed = savedChunkSeed();
                                    }
                                }
                                hits++;
                            }
                        }

                        if (!isOceanic(right)) {
                            savedSeed = savedChunkSeed();
                            this.initChunkSeed((long) (j2 + par1), (long)(i2 + par2));
                            if (this.nextInt(changeChances) < maxLandAdvance) {
                                if (hits == 0) {
                                    i4 = right;
                                } else {
                                    if (i4 != right) {
                                        restoreChunkSeed(savedSeed);
                                        if (nextInt(hits) == 0) {
                                            i4 = right;
                                        }
                                        savedSeed = savedChunkSeed();
                                    }
                                }
                                hits++;
                            }
                        }

                        if (!isOceanic(down)) {
                            savedSeed = savedChunkSeed();
                            this.initChunkSeed((long) (j2 + par1), (long)(i2 + par2));
                            if (this.nextInt(changeChances) < maxLandAdvance) {
                                if (hits == 0) {
                                    i4 = down;
                                } else {
                                    if (i4 != down) {
                                        restoreChunkSeed(savedSeed);
                                        if (nextInt(hits) == 0) {
                                            i4 = down;
                                        }
                                        savedSeed = savedChunkSeed();
                                    }
                                }
                                hits++;
                            }
                        }
                    }
                    aint1[j2 + i2 * par3] = i4;
                    if (aint1[j2 + i2 * par3] == undefined) throw new RuntimeException();
                }
                else if (!isOceanic(k3) && (isOceanic(up) || isOceanic(left) || isOceanic(right) || isOceanic(down))){
                    int i4 = k3;

                    long savedSeed = savedChunkSeed();
                    if (isOceanic(up) ) {
                        this.initChunkSeed((long)(j2 + par1), (long)(i2 + par2));
                        if (this.nextInt(changeChances)>= minSeaAdvance) {
                           i4 = up;
                        }
                    }

                    if (isOceanic(left)) {
                        this.initChunkSeed((long)(j2 + par1), (long)(i2 + par2));
                        if (this.nextInt(changeChances)>= minSeaAdvance) {
                           i4 = left;
                        }
                    }
                    if (isOceanic(right)) {
                        this.initChunkSeed((long)(j2 + par1), (long)(i2 + par2));
                        if (this.nextInt(changeChances)>= minSeaAdvance) {
                           i4=right;
                        }
                    }

                    if (isOceanic(down)) {
                        this.initChunkSeed((long)(j2 + par1), (long)(i2 + par2));
                        if (this.nextInt(changeChances)>= minSeaAdvance) {
                           i4=down;
                        }
                    }
                    aint1[j2 + i2 * par3] = i4;
                    if (aint1[j2 + i2 * par3] == undefined) throw new RuntimeException();
                }
                else {
                    aint1[j2 + i2 * par3] = k3;
                if (aint1[j2 + i2 * par3] == undefined) throw new RuntimeException();
                }
                if (aint1[j2 + i2 * par3] == undefined) throw new RuntimeException();
            }
        }

        return aint1;
    }
}